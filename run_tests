"""
测试点运行脚本
自动运行testcases文件夹中的所有测试点并比对结果
"""

import json
import os
import subprocess
import time
import sys
from pathlib import Path

# 配置项
EXECUTABLE = './code'  # 可执行文件路径，根据实际情况修改
CONFIG_FILE = 'testcases/config.json'
TESTCASES_DIR = 'testcases'
OUTPUT_DIR = 'test_output'  # 存储测试输出
DATA_DIR = 'test_data'  # 程序运行时产生数据文件的目录

# 颜色输出
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_colored(text, color):
    """彩色输出"""
    print(f"{color}{text}{Colors.ENDC}")

def clean_data_files():
    """清理程序运行产生的数据文件"""
    import shutil
    # 删除整个数据目录
    if os.path.exists(DATA_DIR):
        try:
            shutil.rmtree(DATA_DIR)
        except Exception as e:
            print(f"警告: 清理数据目录失败: {e}")
    # 重新创建空目录
    os.makedirs(DATA_DIR, exist_ok=True)

def load_config():
    """加载配置文件"""
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def run_single_test(test_point_id, input_file, time_limit_ms=10000):
    """
    运行单个测试点
    
    Args:
        test_point_id: 测试点编号
        input_file: 输入文件路径
        time_limit_ms: 时间限制（毫秒）
    
    Returns:
        tuple: (是否成功, 输出内容, 运行时间, 错误信息)
    """
    output_file = os.path.join(OUTPUT_DIR, f'{test_point_id}.out')
    
    try:
        start_time = time.time()
        with open(input_file, 'r') as fin:
            with open(output_file, 'w') as fout:
                process = subprocess.Popen(
                    [os.path.abspath(EXECUTABLE)],
                    stdin=fin,
                    stdout=fout,
                    stderr=subprocess.PIPE,
                    text=True,
                    cwd=DATA_DIR  # 在数据目录中运行程序
                )
                
                # 等待进程结束，设置超时
                timeout_sec = time_limit_ms / 1000.0
                try:
                    stderr_output = process.communicate(timeout=timeout_sec)[1]
                    elapsed_time = (time.time() - start_time) * 1000  # 转换为毫秒
                    
                    if process.returncode != 0:
                        return False, None, elapsed_time, f"运行时错误 (返回码: {process.returncode})\n{stderr_output}"
                    
                    with open(output_file, 'r') as f:
                        output = f.read()
                    
                    return True, output, elapsed_time, None
                    
                except subprocess.TimeoutExpired:
                    process.kill()
                    elapsed_time = (time.time() - start_time) * 1000
                    return False, None, elapsed_time, f"超时 (限制: {time_limit_ms}ms)"
                    
    except FileNotFoundError:
        return False, None, 0, f"可执行文件未找到: {EXECUTABLE}"
    except Exception as e:
        return False, None, 0, f"运行错误: {str(e)}"

def compare_output(output, answer_file):
    """
    比对输出和标准答案
    
    Args:
        output: 程序输出
        answer_file: 标准答案文件路径
    
    Returns:
        tuple: (是否正确, 差异信息)
    """
    if not os.path.exists(answer_file):
        return None, "标准答案文件不存在"
    
    with open(answer_file, 'r') as f:
        answer = f.read()
    
    # 规范化输出（去除行末空格和文件末空行）
    output_lines = [line.rstrip() for line in output.splitlines()]
    answer_lines = [line.rstrip() for line in answer.splitlines()]
    
    # 去除末尾的空行
    while output_lines and not output_lines[-1]:
        output_lines.pop()
    while answer_lines and not answer_lines[-1]:
        answer_lines.pop()
    
    if output_lines == answer_lines:
        return True, None
    
    # 生成差异信息
    diff_info = []
    max_lines = max(len(output_lines), len(answer_lines))
    for i in range(max_lines):
        out_line = output_lines[i] if i < len(output_lines) else "<EOF>"
        ans_line = answer_lines[i] if i < len(answer_lines) else "<EOF>"
        if out_line != ans_line:
            diff_info.append(f"第 {i+1} 行不同:")
            diff_info.append(f"  输出: {out_line}")
            diff_info.append(f"  答案: {ans_line}")
            if len(diff_info) >= 10:  # 只显示前几个差异
                diff_info.append("  ...")
                break
    
    return False, "\n".join(diff_info)

def run_test_group(group, test_details):
    """
    运行一个测试组
    
    Args:
        group: 测试组配置
        test_details: 测试点详细配置字典
    
    Returns:
        tuple: (通过数, 总数, 详细结果列表)
    """
    group_name = group['GroupName']
    test_points = group['TestPoints']
    group_dir = os.path.join(TESTCASES_DIR, group_name)
    
    # 每个测试组开始前清理数据文件
    clean_data_files()
    
    passed = 0
    total = len(test_points)
    results = []
    
    for idx, point_id in enumerate(test_points, 1):
        input_file = os.path.join(group_dir, f'{point_id}.in')
        answer_file = os.path.join(group_dir, f'{point_id}.out')
        
        # 实时显示当前运行的测试点
        print(f"  运行测试点 {point_id:3d} ({idx}/{total})...", end='', flush=True)
        
        if not os.path.exists(input_file):
            print(f" {Colors.YELLOW}跳过{Colors.ENDC}")
            results.append({
                'id': point_id,
                'status': 'SKIP',
                'message': '输入文件不存在',
                'time': 0
            })
            continue
        
        # 获取时间限制
        time_limit = test_details.get(point_id, {}).get('TimeLimit', 10000)
        
        # 运行测试
        success, output, elapsed_time, error = run_single_test(point_id, input_file, time_limit)
        
        if not success:
            print(f" {Colors.RED}✗ 错误{Colors.ENDC} ({elapsed_time:.1f}ms)")
            results.append({
                'id': point_id,
                'status': 'ERROR',
                'message': error,
                'time': elapsed_time
            })
            break  # 遇到错误立即停止
        
        # 比对结果
        correct, diff = compare_output(output, answer_file)
        
        if correct is None:
            print(f" {Colors.YELLOW}? 无答案{Colors.ENDC}")
            results.append({
                'id': point_id,
                'status': 'NO_ANS',
                'message': diff,
                'time': elapsed_time
            })
            break  # 遇到无答案立即停止
        elif correct:
            print(f" {Colors.GREEN}✓ 通过{Colors.ENDC} ({elapsed_time:.1f}ms)")
            passed += 1
            results.append({
                'id': point_id,
                'status': 'PASS',
                'message': None,
                'time': elapsed_time
            })
            # 删除通过的测试点的输出文件
            try:
                os.remove(os.path.join(OUTPUT_DIR, f'{point_id}.out'))
            except:
                pass
        else:
            print(f" {Colors.RED}✗ 错误{Colors.ENDC} ({elapsed_time:.1f}ms)")
            results.append({
                'id': point_id,
                'status': 'WRONG',
                'message': diff,
                'time': elapsed_time
            })
            break  # 遇到答案错误立即停止
    # 测试组结束后再次清理数据文件
    clean_data_files()
    
    
    return passed, total, results

def print_result(result):
    """打印单个测试结果"""
    status = result['status']
    test_id = result['id']
    time_ms = result['time']
    
    if status == 'PASS':
        print_colored(f"  ✓ 测试点 {test_id:3d}: 通过 ({time_ms:.1f}ms)", Colors.GREEN)
    elif status == 'WRONG':
        print_colored(f"  ✗ 测试点 {test_id:3d}: 答案错误 ({time_ms:.1f}ms)", Colors.RED)
        if result['message']:
            print(f"    {result['message']}")
    elif status == 'ERROR':
        print_colored(f"  ✗ 测试点 {test_id:3d}: {result['message']}", Colors.RED)
    elif status == 'NO_ANS':
        print_colored(f"  ? 测试点 {test_id:3d}: {result['message']}", Colors.YELLOW)
    elif status == 'SKIP':
        print_colored(f"  - 测试点 {test_id:3d}: {result['message']}", Colors.YELLOW)

def main():
    """主函数"""
    print_colored("=" * 60, Colors.CYAN)
    print_colored("Bookstore 测试运行器", Colors.BOLD)
    print_colored("=" * 60, Colors.CYAN)
    print()
    
    # 检查可执行文件
    if not os.path.exists(EXECUTABLE):
        print_colored(f"错误: 找不到可执行文件 {EXECUTABLE}", Colors.RED)
        print("请先编译程序或修改脚本中的 EXECUTABLE 变量")
        sys.exit(1)
    
    # 创建输出目录和数据目录
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    os.makedirs(DATA_DIR, exist_ok=True)
    
    # 加载配置
    try:
        config = load_config()
    except Exception as e:
        print_colored(f"错误: 无法加载配置文件: {e}", Colors.RED)
        sys.exit(1)
    
    # 构建测试点详细信息字典
    test_details = {}
    if 'Details' in config:
        for detail in config['Details']:
            test_details[detail['ID']] = detail
    
    # 运行所有测试组
    total_passed = 0
    total_tests = 0
    total_score = 0
    max_score = 0
    
    for group_idx, group in enumerate(config['Groups'], 1):
        group_name = group['GroupName']
        group_score = group['GroupScore']
        test_count = len(group['TestPoints'])
        max_score += group_score
        
        print_colored(f"\n【{group_name}】[{group_idx}/{len(config['Groups'])}] (分值: {group_score}, 测试点: {test_count})", Colors.BLUE)
        
        passed, total, results = run_test_group(group, test_details)
        total_passed += passed
        total_tests += total
        
        # 打印该组详细结果（只显示错误的测试点）
        has_error = False
        for result in results:
            if result['status'] != 'PASS':
                print_result(result)
                has_error = True
        
        # 计算该组得分
        if passed == total:
            group_earned = group_score
            print_colored(f"  组得分: {group_earned}/{group_score} ✓ 全部通过!", Colors.GREEN)
            total_score += group_earned
        else:
            print_colored(f"  组得分: 0/{group_score} (通过 {passed}/{total})", Colors.RED)
        
        # 如果有错误，停止后续测试组
        if has_error:
            print_colored(f"\n测试在 {group_name} 遇到错误，停止执行后续测试", Colors.YELLOW)
            break
    
    # 打印总结
    print_colored("\n" + "=" * 60, Colors.CYAN)
    print_colored("测试总结", Colors.BOLD)
    print_colored("=" * 60, Colors.CYAN)
    print(f"通过测试点: {total_passed}/{total_tests}")
    print(f"总得分: {total_score}/{max_score}")
    accuracy = (total_passed / total_tests * 100) if total_tests > 0 else 0
    print(f"正确率: {accuracy:.2f}%")
    print_colored("=" * 60, Colors.CYAN)
    
    # 清理test_data文件夹
    import shutil
    if os.path.exists(DATA_DIR):
        try:
            shutil.rmtree(DATA_DIR)
            print(f"\n已清理数据目录: {DATA_DIR}")
        except Exception as e:
            print(f"\n警告: 清理数据目录失败: {e}")
    
    # 返回状态码
    sys.exit(0 if total_passed == total_tests else 1)

if __name__ == '__main__':
    main()
